.MODEL SMALL
.STACK 100H
.DATA
msg1  DW  'Enter size of array :$'
msg2  DW  ,0AH,0DH,'Array elements are :$'  
msg3  DW  ,0AH,0DH,'size of array must be positive interger:  $'
ARRAY DW 255 DUP(?)    
.CODE

MAIN PROC

	MOV AX, @DATA                	; initialize DS
     	MOV DS, AX
     	LEA DX, msg1             	; load address of msg1 in DX
     	MOV AH, 9                    	; AH value for dos interrupt to print msg1
     	INT 21H                      	; interrupt dos that takes input from user
    
     	LEA SI, ARRAY              	; load adderss of ARRAY in SI
	CALL Get_Size			; get size and put it in AX





validation_check PROC 
    push bx                       ; push BX inthe STACK
   
    lable_READ0:
 
     XOR CX,CX                    ; put CX register equals to zero, CX==0
     XOR BX,BX                    ; put BX register equals to zero, BX==0
     XOR AX,AX                    ; put AX register equals to zero, AX==0
     
     Mov AH,1                     ; read a character
     INT 21h                      ; interrupt dos that takes input from user
     
     cmp    al, '-'               ; compare input with -
     JE lable_NEGATIVE                 ; JUMP to NEGATIVE lable if the input equals(-)
     
     cmp al,'+'                   ;compare input with +
     jE lable_POSITIVE                 ; JUMP to POSITIVE lable if the input equals(+)       
     jmp lable_input0                  ; JUMP to input0 lable        
              
    lable_NEGATIVE:                    ; NEGATIVE lable
     INC CL                       ; CL=CL+1
     JMP lable_ERROR0                  ; JUMP to ERROR0 lable
   
    lable_POSITIVE:                    ; POSITIVE lable
     INC CL                       ; CL=CL+1
     JMP lable_ERROR0                  ; JUMP to ERROR0 lable 
     
            
      lable_INPUT0:                      ; INPUT0 lable
     MOV BL,AL                    ; BL=AL
     MOV AH, 1                    ; read a character
     INT 21H                      ; interrupt dos that takes input from user

    lable_SKIP_INPUT0:                 ; SKIP_INPUT0 label
     CMP AL, 0DH                  ; compare AL with Return (enter)
     JE lable_END_INPUT0               ; jump to label lable_END_INPUT if the input equals (enter)  

     CMP AL, 8H                   ; compare AL with 8H   (backspace)
     JNE lable_NOT_BACKSPACE0          ; jump to label lable_NOT_BACKSPACE if AL!=8
 
    lable_MOVE_BACK0:                  ; MOVE_BACK0 label
     MOV AH, 2                    ; put output function
     MOV DL, 20H                  ; put DL=' '
     INT 21H                      ; print a character
     MOV DL, 8H                   ; put DL=8H
     INT 21H                      ; print a character
     XOR DX, DX                   ; clear DX
     DEC CL                       ; put CL=CL-1
     JMP lable_INPUT0                  ; jump to label lable_INPUT0     

    lable_NOT_BACKSPACE0:              ; NOT_BACKSPACE0 label
     INC CL                       ; put CL=CL+1
     CMP AL, 30H                  ; compare AL with 0
     JL lable_ERROR0                   ; jump to label lable_ERROR0if AL<0
     CMP AL, 39H                  ; compare AL with 9
     JG lable_ERROR0                   ; jump to label lable_ERROR0if AL>9
     AND AX, 000FH                ; convert ascii to decimal code  

     PUSH AX                      ; push AX inthe STACK
     MOV AX, 10                   ; put AX=10
     MUL BX                       ; put AX=AX*BX
     MOV BX, AX                   ; put BX=AX
     POP AX                       ; pop a value from STACK into AX
     ADD BX, AX                   ; put BX=AX+BX
     JS lable_ERROR0                   ; jump to label lable_ERROR if SF=1
     JMP lable_INPUT0                  ; jump to label lable_INPUT0    
                       
    lable_ERROR0:                      ; ERROR0 label
     MOV AH, 2                    ; put output function
     MOV DL, 7H                   ; put DL=7H  (beep sound)
     INT 21H                      ; print a character
     
    lable_CLEAR0:                      ; CLEAR0 label  
     MOV DL, 8H                   ; put DL=8H (backspace in ascii)
     INT 21H                      ; print a character
     MOV DL, 20H                  ; put DL=' '(Space in ascii)
     INT 21H                      ; print a character
     MOV DL, 8H                   ; put DL=8H (backspace in ascii)
     INT 21H                      ; print a character 
    LOOP lable_CLEAR0                  ; jump to label lable_CLEAR0 if CX!=0
    JMP lable_READ0                    ; jump to label lable_READ0
       
   lable_END_INPUT0:                   ; END_INPUT0 label  






QUICK_SORT: 
        mov  ax, p
        cmp  ax, r                  ;COMPARE P WITH R
        jge  @bigger1                ;IF P = R, SORT IS DONE.
    
        ;CALL PARTITION(A, P, R).
        call partition
    
        ;GET Q = PARTITION(A, P, R).
        mov  q, ax
    
        ;PUSH Q+1, R INTO STACK FOR LATER USAGE.
        inc  ax
        push ax
        push r
    
        ;CALL QUICKSORT(A, P, Q-1).
        mov  ax, q
        mov  r, ax
        dec  r
        call QUICK_SORT
    
        ;CALL QUICKSORT(A, Q+1, R).
        pop  r
        pop  p 
        call QUICK_SORT 
    
        ;WHEN SORT IS DONE.
        @bigger1:
          RET 
            
Get_Size PROC		; function to take array size from user (must be positive number from 0 to 255)
        
    
   PUSH BX                        ; push BX in the STACK0
   PUSH CX                        ; push CX in the STACK
   PUSH DX                        ; push DX in the STACK
   

   JMP Label_READ1                     ; jump to label Label_READ
   Label_SKIP_BACKSPACE1:              ; SKIP_BACKSPACE1 label
   MOV AH, 2                      ; output function
   MOV DL, 20H                    ; DL=' ' space
   INT 21H                        ; print a character
   Label_READ1:                        ; READ1 label

   XOR BX, BX                     ; clear BX
   XOR CX, CX                     ; clear CX
   XOR DX, DX                     ; clear DX
   MOV AH, 1                      ; input function
   INT 21H                        ; read input
   AND AX, 000FH                  ; ascii 2 decimal 

   MOV BX, AX                     ; set BX=AX+BX
   MOV AH, 1                      ; set input function
   INT 21H                        ; read input

 CMP AL, "-"                    ; compare AL with "-"
 JE Label_ERROR2                     ; jump to label Label_ERROR2 if AL="-"
 CMP AL, "+"                    ; compare AL with "+"
 JE Label_PLUS1                      ; jump to label Label_PLUS if AL="+"
 JMP Label_SKIP_INPUT1               ; jump to label Label_SKIP_INPUT
Label_PLUS1:                        ; PLUS1 label
  MOV CH, 2                      ; set CH=2
  INC CL                         ; set CL=CL+1
  Label_INPUT1:                       ; jump label
  MOV AH, 1                    ; set input function
  INT 21H                      ; read a character
Label_SKIP_INPUT1:                ; jump label

  CMP AL, 0DH                    ; compare AL with enter

 Label_ERROR1:                       ; jump label
   MOV AH, 2                      ; output function
   MOV DL, 7H                     ; DL=7H
   INT 21H                        ; print a character
   XOR CH, CH                     ; clear CH
    Label_ERROR2:                      ; jump label
   LEA DX, msg3
   MOV AH, 9
   INT 21H
   jmp Label_READ1

   MOV AX, BX                     ; AX=BX
   POP DX                         ; pop from STACK to DX
   POP CX                         ; pop from STACK to CX
   POP BX                         ; pop from STACK to BX
   RET                            ; return to CALL 
   Get_Size ENDP   



GET_ARRAY PROC ; to get array elements size in BX , address of ARRAY[0] in SI

   PUSH AX                        ; push AX in the STACK
   PUSH CX                        ; push CX in the STACK
   PUSH DX                        ; push DX in the STACK
   
   MOV CX, BX                     ;  CX=BX
   Label_GET_ARRAY:               ; loop label
     CALL ASCII_2_DECIMAL         ; call  ASCII_2_DECIMAL
     MOV [SI], AX                 ; [SI]=AX
     ADD SI, 2                    ; SI=SI+2
     MOV DL, 0AH                  ; new line
     MOV AH, 2                    ; for print 
     INT 21H                      ; print a character
   LOOP Label_GET_ARRAY           ; jump to Label_GET_ARRAY while CX!=0
   POP DX                         ; pop  from STACK to DX
   POP CX                         ; pop  from STACK to CX
   POP AX                         ; pop  from STACK to AX
   RET                            ; return to CALL
   GET_ARRAY ENDP






 ASCI_2_DECIMAL PROC
  
 

   PUSH BX                        ; push BX in the STACK
   PUSH CX                        ; push CX in the STACK
   PUSH DX                        ; push DX in the STACK
   
  
JMP Label_READ                    ; jump to label Label_READ 
 Label_SKIP_BACKSPACE:            ; label
   MOV AH, 2                      ; output function
   MOV DL, 20H                    ; put DL=' '
   INT 21H                        ; print 

 Label_READ:                      ; jump label
   XOR BX, BX                     ; BX = 0
   XOR CX, CX                     ; CX = 0
   XOR DX, DX                     ; DX = 0
   MOV AH, 1                      ; input function
   INT 21H                        ; read a character
   CMP AL, "-"                    ; compare AL with "-"
   JE Label_MINUS                 ; jump to Label_MINUS if AL="-"

   CMP AL, "+"                    ; compare AL with "+"
   JE Label_PLUS                  ; jump to Label_PLUS if AL="+"
   JMP Label_SKIP_INPUT           ; jump to Label_SKIP_INPUT
   Label_MINUS:                   ; jump label
   MOV CH, 1                      ; set CH=1
   INC CL                         ; CL = CL + 1
   JMP Label_INPUT                ; jump to Label_INPUT
 
 Label_PLUS:                      ; jump label
   MOV CH, 2                      ; put CH=2
   INC CL                         ; CL=CL+1
   
Label_INPUT:                      ; jump label
   MOV AH, 1                      ; input function
   INT 21H                        ; read a character
   MOV AH, 1                      ; set input function
   INT 21H                        ; read a character
                   
   POP DX                         ; pop  from STACK into DX
   POP CX                         ; pop  from STACK into CX
   POP BX                         ; pop  from STACK into BX
   
RET   
                                  ; return control to the calling procedure
 
ASCI_2_DECIMAL ENDP


DECIMAL_2_ASCII PROC

   PUSH BX                        ; push BX into the STACK
   PUSH CX                        ; push CX into the STACK
   PUSH DX                        ; push DX into the STACK

   CMP AX, 0                      ; compare AX with 0
   JGE LABEL_START                     ; jump to label @START if AX>=0

   PUSH AX                        ; push AX into the STACK

   MOV AH, 2                      ; set output function
   MOV DL, "-"                    ; set DL='-'
   INT 21H                        ; print the character





   POP DX                         ; pop a value from STACK into DX
   POP CX                         ; pop a value from STACK into CX
   POP BX                         ; pop a value from STACK into BX

   RET                            ; return control to the calling procedure
 DECIMAL_2_ASCII ENDP







DISPLAY_ARRAY PROC 		  ; function to display array elements	, address of ARRAY[0] in SI , size in BX 
  
   
   PUSH AX                        ; push AX in the STACK   
   PUSH CX                        ; push CX in the STACK
   PUSH DX                        ; push DX in the STACK

   MOV CX, BX                     ;  CX=BX
   LABEL_PRINT_ARRAY:             ; loop label
     XOR AH, AH                   ; AH = 0
     MOV AX, [SI]                 ; AL=[SI]
     CALL DECIMAL_2_ASCII         ; call DECIMAL_2_ASCII
     MOV AH, 2                    ; output function
     MOV DL, 20H                  ; DL=20H (space)
     INT 21H                      ; print 

     ADD SI,2			  ; SI = SI + 2
   LOOP LABEL_PRINT_ARRAY         ; jump to LABEL_PRINT_ARRAY while CX!=0
   POP DX                         ; pop  from STACK into DX
   POP CX                         ; pop  from STACK into CX
   POP AX                         ; pop  from STACK into AX

   RET                            ; return control to the calling procedure
 DISPLAY_ARRAY ENDP



















END MAIN